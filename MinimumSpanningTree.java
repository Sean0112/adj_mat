package Part2;import java.util.*;import java.util.concurrent.LinkedBlockingQueue;/** * A class that creates a minimum spanning tree * for a given graph * The graph is represented by adjacency matrix * * @author SEAN CARLISLE * @version 12/13/2016 */public class MinimumSpanningTree {    private int[][] adjMatrix;    private int[][] minimumSpanningTree;    private int numberOfNodes;    final int GRAYED_OUT = -1;    final int MARKED_FOR_CHECKING = -1;    final int PERCENT100 = 100;    public MinimumSpanningTree(int numberOfNodes, int probability)    {        this.numberOfNodes = numberOfNodes;        this.adjMatrix = new int[numberOfNodes + 1][numberOfNodes + 1];        this.minimumSpanningTree = new int[numberOfNodes + 1][numberOfNodes + 1];        Random ra = new Random();        for (int r = 2; r <= numberOfNodes; r++) {            for (int c = 1; c < r; c++) {                int randWeight = ra.nextInt(numberOfNodes) + 1;                int randProb = ra.nextInt(PERCENT100);                if (randProb < probability / 2) {                    adjMatrix[r][c] = randWeight;                    adjMatrix[c][r] = randWeight;                }            }        }        adjMatrix[1][0] = MARKED_FOR_CHECKING; //marker for row        adjMatrix[0][1] = GRAYED_OUT; //marker for col    }    public boolean isConnected()    {        // utilizes BFS algorithm        ArrayList<Integer> verts = new ArrayList<>();        for (int r = 2; r <= numberOfNodes; r++) {            for (int c = 1; c <= numberOfNodes; c++) {                if (adjMatrix[r][c] != 0 && !verts.contains(c)) {                    verts.add(c);                }            }        }        LinkedBlockingQueue<Integer> vertQ = new LinkedBlockingQueue<>();        LinkedBlockingQueue<Integer> traverse = new LinkedBlockingQueue<>();        int v = verts.remove(0);        vertQ.offer(v);        traverse.offer(v);        while (!vertQ.isEmpty()) {            v = vertQ.poll();            for (int x = 1; x <= this.numberOfNodes; x++) {                if (adjMatrix[v][x] != 0 && verts.contains(x)) { //neighbor 'x' found                    int neighbor = x;                    int i = verts.indexOf(neighbor);                    verts.remove(i);                    vertQ.offer(neighbor);                    traverse.offer(neighbor);                }            }        }        return traverse.size() == this.numberOfNodes;    }    public boolean minimumSpanTreeCheckForCycle() {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.minimumSpanningTree, 1, visited);    }    public boolean connectedGraphCheckForCycle() {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.adjMatrix, 1, visited);    }    private boolean hasCycle(int[][] graphToCheck, int start, boolean[] visited)    {        visited[start] = true;        for (int j = start + 1; j <= this.numberOfNodes; j++) {            // if start and j are connected return true if either j was visited or recursive call starting with j returns true            if (graphToCheck[start][j] != 0) {                if (visited[j] || hasCycle(graphToCheck, j, visited))                    return true;            }        }        return false;    }    public void calculateMinimumSpanningTree()    {        // utilize findSmallestInMarkedRows method        for (int i = 1; i < this.numberOfNodes; i++) {            Element e = findSmallestInMarkedRows();            this.minimumSpanningTree[e.row][e.column] = e.value;            this.minimumSpanningTree[e.column][e.row] = e.value;        }    }    private Element findSmallestInMarkedRows()    {        int smallest = this.numberOfNodes;        int row = 0;        int col = 0;        for (int r = 1; r <= this.numberOfNodes; r++) {            if (this.adjMatrix[r][0] == MARKED_FOR_CHECKING) {                for (int c = 1; c <= this.numberOfNodes; c++) {                    if (this.adjMatrix[r][c] != 0 && this.adjMatrix[0][c] != GRAYED_OUT && this.adjMatrix[r][c] < smallest) {                        smallest = this.adjMatrix[r][c];                        row = r;                        col = c;                    }                }            }        }        adjMatrix[col][0] = MARKED_FOR_CHECKING;        adjMatrix[0][col] = GRAYED_OUT;        //System.out.println("row= " + row + "; col= " + col + "; smallest= " + smallest);        return new Element(row, col, smallest);    }    public void displayGraph() {        System.out.println("***** GENERATED GRAPH *****");        displayMatrix(this.adjMatrix);    }    public void displayMinimumSpanningTree() {        System.out.println("\n\n***** MINIMUM SPANNING TREE FOR THE ABOVE GRAPH *****");        displayMatrix(this.minimumSpanningTree);    }    private void displayMatrix(int[][] matrix) {        System.out.print("     ");        for (int c = 1; c <= this.numberOfNodes; c++) {            System.out.printf("[%1$2d]", c);        }        System.out.println();        for (int r = 1; r <= this.numberOfNodes; r++) {            //System.out.print(r + " ");            System.out.printf("[%1$2d]", r);            for (int c = 1; c <= this.numberOfNodes; c++) {                if (matrix[r][c] > 0)                    System.out.printf("%1$4d", matrix[r][c]);                else                    System.out.printf("%1$4s", " ");            }            System.out.println();        }    }    public static void main(String[] args) {        System.out.println("How many nodes in your graph?");        Scanner scan = new Scanner(System.in);        int numberOfNodes = scan.nextInt();        System.out.println("Probability of edge? (type 70 for 70%)");        int probability = scan.nextInt();        MinimumSpanningTree graph = new MinimumSpanningTree(numberOfNodes, probability);        graph.displayGraph();        if (graph.isConnected()) {            if (graph.connectedGraphCheckForCycle())                System.out.println("\nThe graph has cycles.");            else                System.out.println("\nThe graph is acyclic.");            graph.calculateMinimumSpanningTree();            graph.displayMinimumSpanningTree();            if (graph.minimumSpanTreeCheckForCycle())                System.out.println("\nThe minimum spanning tree has cycles.");            else                System.out.println("\nThe minimum spanning tree is acyclic.");        } else            System.out.println("The graph is not connected, the minimum spanning tree will not be calculated");    } // end main    private class Element {        private int row;        private int column;        private int value;        public Element(int row, int column, int value) {            this.row = row;            this.column = column;            this.value = value;        }    }}